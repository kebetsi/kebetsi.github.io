"use strict";(self.webpackChunkilia_kebets_tech_blog=self.webpackChunkilia_kebets_tech_blog||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"Multipart-Form-data-response-parsing-in-Java-and-JavaScript","metadata":{"permalink":"/blog/Multipart-Form-data-response-parsing-in-Java-and-JavaScript","editUrl":"https://github.com/kebetsi/kebetsi.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/2024-09-16-form-data-response/index.md","source":"@site/blog/2024-09-16-form-data-response/index.md","title":"Multipart Form-data response parsing in Java and JavaScript","description":"In this article, I will show you how to implement an HTTP server that replies with form-data and how to parse it from the client. I will provide examples for the server in Node.js, using external libraries and native ones. For the client, I will show implementations in JS and Java.","date":"2024-09-16T00:00:00.000Z","tags":[{"inline":false,"label":"JavaScript","permalink":"/blog/tags/javascript","description":"all things about JS"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"all things about Java"},{"inline":true,"label":"http","permalink":"/blog/tags/http"},{"inline":true,"label":"response","permalink":"/blog/tags/response"},{"inline":true,"label":"multipart-form-data","permalink":"/blog/tags/multipart-form-data"}],"readingTime":10.19,"hasTruncateMarker":true,"authors":[{"name":"Ilia Kebets","title":"Software engineer @ Sonar","url":"https://github.com/kebetsi","page":{"permalink":"/blog/authors/ilia"},"socials":{"linkedin":"https://www.linkedin.com/in/iliakebets/","github":"https://github.com/kebetsi"},"imageURL":"https://github.com/kebetsi.png","key":"ilia"}],"frontMatter":{"slug":"Multipart-Form-data-response-parsing-in-Java-and-JavaScript","title":"Multipart Form-data response parsing in Java and JavaScript","authors":["ilia"],"tags":["javascript","java","http","response","multipart-form-data"]},"unlisted":false,"nextItem":{"title":"MacOS software development tools","permalink":"/blog/MacOS-software-development-tools"}},"content":"In this article, I will show you how to implement an HTTP server that **replies with form-data** and how to parse it from the client. I will provide examples for the server in Node.js, using external libraries and native ones. For the client, I will show implementations in JS and Java.\\n\\n\x3c!-- truncate --\x3e\\n\\nI will illustrate cases where the parts are only text and a mix of text and binary data.\\n\\n[Form-data is the way browsers send the contents of the `<form>` element](https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data). It is also the way for the HTTP protocol to send key-value data in a POST request which supports values of different formats, such as text and binary.\\n\\n## Form-data with text\\n\\n![HTTP response of multipart/form-data with text parts](./form-data-txt.webp)\\n\\n### JS server \u2014 with libraries\\n\\nWe use the [express](https://www.npmjs.com/package/express) and [form-data](https://www.npmjs.com/package/form-data) libraries in this example for convenience.\\n\\nWe use JSON data for the text, but it can also be plain text. We append each part with its name, here `message1` and `message2` to the `formData` instance, set the required headers. Finally, we must pipe it into the response stream.\\n\\nI had to use `127.0.0.1` instead of `localhost` for the host address on the JS server side, because the Java clients would not resolve it.\\n\\n```js\\nconst http = require(\'http\');\\nconst app = require(\'express\')();\\nconst formData = require(\'form-data\');\\nconst PORT = \'9876\';\\nconst HOST = \'127.0.0.1\';\\n\\nconst message1 = JSON.stringify({ hello: \'world\' });\\nconst message2 = JSON.stringify({ foo: \'bar\' });\\n\\nconst requestHandler = ((_, response) => {\\n  const fd = new formData();\\n  fd.append(\'message1\', message1);\\n  fd.append(\'message2\', message2);\\n  // generates the \\"multipart/form-data; boundary=...\\" header\\n  response.set(\'Content-Type\', fd.getHeaders()[\'content-type\']);\\n  response.set(\'Content-Length\', fd.getLengthSync());\\n  fd.pipe(response);\\n});\\n\\napp.use(requestHandler);\\n\\nconst server = http.createServer(app);\\nserver.listen(PORT, HOST, err => {\\n  if (err) {\\n    return console.log(\'something bad happened\', err);\\n  }\\n  console.log(`server is listening on ${HOST}:${PORT}`);\\n});\\n```\\n\\n### JS server \u2014 without libraries\\n\\nFor a unit test in the Java component, I had to implement a mock server that was not using any libraries. It helped me have a better understanding of the form-data layout.\\n\\nThe body starts with the boundary string which is then used to split every part of the message. The boundary must have a length of up to 70 characters, and you can read more about it [here](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html).\\n\\nThen, each part is organized as follows:\\n\\n1. Starts with `\\\\r\\\\n`\\n2. its header, which contains the name of the part\\n3. 2 times `\\\\r\\\\n`\\n4. its body\\n5. ends with `\\\\r\\\\n`\\n\\nWe must ensure that the body length in bytes is properly computed and not forget the `Content-Type` header.\\n\\n```js\\nconst http = require(\'http\');\\nconst formData = require(\'form-data\');\\nconst PORT = \'9876\';\\nconst HOST = \'127.0.0.1\';\\n\\nconst message1 = JSON.stringify({ hello: \'world\' });\\nconst message2 = JSON.stringify({ foo: \'bar\' });\\n\\nconst requestHandler = (request, response) => {\\n  let data = \'\';\\n  request.on(\'data\', chunk => (data += chunk));\\n  request.on(\'end\', () => {\\n    // do something with the incoming data if needed\\n    const boundary = \'---------9051914041544843365972754266\';\\n    const contentTypeHeader = `multipart/form-data; boundary=${boundary}`;\\n    let body = \'\';\\n    body += `--${boundary}`;\\n    body += `\\\\r\\\\n`;\\n    body += `Content-Disposition: form-data; name=\\"message1\\"`;\\n    body += `\\\\r\\\\n`;\\n    body += `\\\\r\\\\n`;\\n    body += `${message1}`;\\n    body += `\\\\r\\\\n`;\\n    body += `--${boundary}`;\\n    body += `\\\\r\\\\n`;\\n    body += `Content-Disposition: form-data; name=\\"message2\\"`;\\n    body += `\\\\r\\\\n`;\\n    body += `\\\\r\\\\n`;\\n    body += `${message2}`;\\n    body += `\\\\r\\\\n`;\\n    body += `--${boundary}--`;\\n    body += `\\\\r\\\\n`;\\n    response.writeHead(200, {\\n      \'Content-Type\': contentTypeHeader,\\n      \'Content-Length\': Buffer.byteLength(body, \'utf-8\'),\\n    });\\n    response.end(body);\\n  });\\n};\\n\\nconst server = http.createServer(requestHandler);\\n\\nserver.listen(PORT, HOST, err => {\\n  if (err) {\\n    return console.log(\'something bad happened\', err);\\n  }\\n  console.log(`server is listening on ${HOST}:${PORT}`);\\n});\\n```\\n\\n### Java client\\n\\nWe start by extracting the boundary string from the `Content-Type` header, which we use to split the separate parts of the body with `response.body().split(...)`. Most client libraries will generate one for you as you saw in the previous example.\\n\\nThen we use the `\\\\r\\\\n\\\\r\\\\n` separator to split between each part\u2019s header and body. As you can see in the library-less server implementation above, we must trim the `\\\\r\\\\n` form-data boilerplate. If we are handling JSON data, we could simplify this part using [String.trim()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--).\\n\\n```java\\nimport java.net.URI;\\nimport java.net.URISyntaxException;\\nimport java.net.http.HttpClient;\\nimport java.net.http.HttpRequest;\\nimport java.net.http.HttpResponse;\\nimport java.net.http.HttpResponse.BodyHandlers;\\nimport java.time.Duration;\\n\\npublic class MyClient {\\n\\n  public record MyApiResponse(String message1, String message2) {};\\n\\n  public static MyApiResponse parseFormData(String contentTypeHeader, String responseBody) {\\n    String boundary = \\"--\\" + contentTypeHeader.split(\\"boundary=\\")[1];\\n    String[] parts = responseBody.split(boundary);\\n    String message1 = null;\\n    String message2 = null;\\n    for (String part : parts) {\\n      // Split the part into headers and body\\n      int separatorIndex = part.indexOf(\\"\\\\r\\\\n\\\\r\\\\n\\");\\n      if (separatorIndex == -1) {\\n        // Skip if there\'s no body\\n        continue;\\n      }\\n      // I remove the first 2 bytes, representing \\"\\\\r\\\\n\\" before the headers\\n      String headers = part.substring(2, separatorIndex);\\n      // I remove the first 4 bytes and last 2.\\n      // They are the \\"\\\\r\\\\n\\\\r\\\\n\\" before and \\"\\\\r\\\\n\\" after the payload\\n      String partBody = part.substring(separatorIndex + 4, part.length() - 2);\\n\\n      if (headers.contains(\\"message1\\")) {\\n        message1 = partBody;\\n      } else if (headers.contains(\\"message2\\")) {\\n        message2 = partBody;\\n      }\\n    }\\n    if (message1 == null || message2 == null) {\\n      throw new IllegalStateException(\\"Data missing from response\\");\\n    }\\n    return new MyApiResponse(message1, message2);\\n  }\\n\\n  public static MyApiResponse sendRequest(String host, int port) throws Exception {\\n    HttpRequest request =\\n      HttpRequest\\n        .newBuilder()\\n        .uri(url(host, port, \\"hello\\"))\\n        .GET()\\n        .build();\\n    HttpClient client =\\n      HttpClient\\n        .newBuilder()\\n        .connectTimeout(Duration.ofSeconds(30))\\n        .build();\\n    HttpResponse<String> response =\\n      client\\n        .send(request, BodyHandlers.ofString());\\n    String contentTypeHeader = response.headers()\\n      .firstValue(\\"Content-Type\\")\\n      .orElseThrow(() -> new IllegalStateException(\\"No Content-Type header\\"));\\n    String responseBody = response.body();\\n    return parseFormData(contentTypeHeader, responseBody);\\n  }\\n\\n  private static URI url(String host, int port, String endpoint) {\\n    try {\\n      return new URI(\\"http\\", null, host, port, \\"/\\" + endpoint, null, null);\\n    } catch (URISyntaxException e) {\\n      throw new IllegalStateException(\\"Invalid URI: \\" + e.getMessage(), e);\\n    }\\n  }\\n\\n  public static void main(String[] args) throws Exception {\\n    MyApiResponse response = sendRequest(\\"localhost\\", 9876);\\n    System.out.println(response); // MyApiResponse[message1={\\"hello\\":\\"world\\"}, message2={\\"foo\\":\\"bar\\"}]\\n  }\\n}\\n```\\n\\n### JS client\\n\\nFor the HTTP request, we use the [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) available in modern browsers and Node.js since version 18.\\n\\n```js\\nasync function request(host, port) {\\n  const res = await fetch(`http://${host}:${port}/hello`);\\n  const fd = await res.formData();\\n  const message1 = fd.get(\'message1\');\\n  const message2 = fd.get(\'message2\');\\n  return [message1, message2];\\n}\\n\\n(async () => {\\n  const response = await request(\'localhost\', 9876)\\n  console.log(response); // [ \'{\\"hello\\":\\"world\\"}\', \'{\\"foo\\":\\"bar\\"}\' ]\\n})();\\n```\\n\\n## Form-data with binary data\\n\\n![HTTP response of multipart/form-data with text and binary parts](./form-data-data.webp)\\n\\nWe change the `message2` part to be treated as a binary, while `message1` stays the same.\\n\\n### JS server \u2014 with libraries\\n\\nWe use a simple string for `message2`, but it accepts a Buffer object such as the bytes from a file given by the result of `fs.readFileSync()`.\\n\\n```js\\nconst http = require(\'http\');\\nconst app = require(\'express\')();\\nconst formData = require(\'form-data\');\\n// const fs = require(\'fs\');\\n\\nconst PORT = \'9876\';\\nconst HOST = \'127.0.0.1\';\\n\\nconst message1 = JSON.stringify({ hello: \'world\' });\\nconst message2 = Buffer.from(\'foo=bar\');\\n// const message2 = fs.readFileSync(\'path/to/my/file\');\\n\\nconst requestHandler = ((_, response) => {\\n  const fd = new formData();\\n  fd.append(\'message1\', message1);\\n  fd.append(\'message2\', message2);\\n  response.set(\'Content-Type\', fd.getHeaders()[\'content-type\']);\\n  response.set(\'Content-Length\', fd.getLengthSync());\\n  fd.pipe(response);\\n});\\n\\napp.use(requestHandler);\\n\\nconst server = http.createServer(app);\\nserver.listen(PORT, HOST, err => {\\n  if (err) {\\n    return console.log(\'something bad happened\', err);\\n  }\\n  console.log(`server is listening on ${HOST}:${PORT}`);\\n});\\n```\\n\\n### JS server \u2014 without libraries\\n\\nWhen sending binary data, we need to convert the string parts and separators using [Buffer.from()](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding) and join them using [Buffer.concat()](https://nodejs.org/api/buffer.html#static-method-bufferconcatlist-totallength).\\n\\nFor the binary part, we need to add a `Content-Type` header inside the body.\\n\\n```js\\nconst http = require(\'http\');\\nconst formData = require(\'form-data\');\\n// const fs = require(\'fs\');\\n\\nconst PORT = \'9876\';\\nconst HOST = \'127.0.0.1\';\\n\\nconst message1 = JSON.stringify({ hello: \'world\' });\\nconst message2 = Buffer.from(\'foo=bar\');\\n// const message2 = fs.readFileSync(\'path/to/my/file\');\\n\\nconst requestHandler = (request, response) => {\\n  let data = \'\';\\n  request.on(\'data\', chunk => (data += chunk));\\n  request.on(\'end\', () => {\\n\\n    const boundary = \'---------9051914041544843365972754266\';\\n    const contentTypeHeader = `multipart/form-data; boundary=${boundary}`;\\n    let firstPart = \'\';\\n    firstPart += `--${boundary}`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `Content-Disposition: form-data; name=\\"message1\\"`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `${message1}`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `--${boundary}`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `Content-Disposition: form-data; name=\\"message2\\"`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `Content-Type: application/octet-stream`;\\n    firstPart += `\\\\r\\\\n`;\\n    firstPart += `\\\\r\\\\n`;\\n    let lastPart = \'\';\\n    lastPart += `\\\\r\\\\n`;\\n    lastPart += `--${boundary}--`;\\n    lastPart += `\\\\r\\\\n`;\\n    const body = Buffer.concat([Buffer.from(firstPart), message2, Buffer.from(lastPart)]);\\n    const contentLength = body.length;\\n    response.writeHead(200, {\\n      \'Content-Type\': contentTypeHeader,\\n      \'Content-Length\': contentLength,\\n    });\\n    response.end(body);\\n  });\\n};\\n\\nconst server = http.createServer(requestHandler);\\n\\nserver.listen(PORT, HOST, err => {\\n  if (err) {\\n    return console.log(\'something bad happened\', err);\\n  }\\n  console.log(`server is listening on ${HOST}:${PORT}`);\\n});\\n```\\n\\n### Java client\\n\\nNow, the change is that the HTTP response body is a byte array, so we must manipulate bytes instead of Strings in our parsing function.\\n\\nFirst, we translate the boundary in bytes using `boundary.getBytes()`.\\n\\nThen we use custom `indexOf()` and `split()` methods that operate on bytes to separate the Form-Data parts. We must also trim the headers and body of the different parts.\\n\\n```java\\nimport java.net.http.HttpClient;\\nimport java.net.http.HttpRequest;\\nimport java.net.http.HttpResponse;\\nimport java.net.http.HttpResponse.BodyHandlers;\\nimport java.net.URI;\\nimport java.net.URISyntaxException;\\nimport java.nio.charset.StandardCharsets;\\nimport java.time.Duration;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\n\\npublic class MyClientData {\\n\\n  public record MyApiResponse(String message1, byte[] message2) {};\\n\\n  public static MyApiResponse parseFormData(String contentTypeHeader, byte[] responseBody) {\\n    String boundary = \\"--\\" + contentTypeHeader.split(\\"boundary=\\")[1];\\n    byte[] boundaryBytes = boundary.getBytes(StandardCharsets.ISO_8859_1);\\n    List<byte[]> parts = split(responseBody, boundaryBytes);\\n\\n    String message1 = null;\\n    byte[] message2 = null;\\n\\n    for (byte[] part : parts) {\\n      int separatorIndex = indexOf(part, \\"\\\\r\\\\n\\\\r\\\\n\\".getBytes(StandardCharsets.ISO_8859_1));\\n      if (separatorIndex == -1) {\\n        // Skip if there\'s no body\\n        continue;\\n      }\\n\\n      // I remove the first 2 bytes, representing \\"\\\\r\\\\n\\" before the headers\\n      byte[] headers = Arrays.copyOfRange(part, 2, separatorIndex);\\n      // I remove the first 4 bytes and last 2.\\n      // They are the \\"\\\\r\\\\n\\\\r\\\\n\\" before and \\"\\\\r\\\\n\\" after the payload\\n      byte[] body = Arrays.copyOfRange(part, separatorIndex + 4, part.length - 2);\\n\\n      String headersStr = new String(headers, StandardCharsets.UTF_8);\\n\\n      if (headersStr.contains(\\"message1\\")) {\\n        message1 = new String(body, StandardCharsets.UTF_8);\\n      } else if (headersStr.contains(\\"message2\\")) {\\n        message2 = body;\\n      }\\n    }\\n    if (message1 == null || message2 == null) {\\n      throw new IllegalStateException(\\"Data missing from response\\");\\n    }\\n    return new MyApiResponse(message1, message2);\\n  }\\n\\n  private static int indexOf(byte[] array, byte[] pattern) {\\n    for (int i = 0; i < array.length - pattern.length + 1; i++) {\\n      boolean found = true;\\n      for (int j = 0; j < pattern.length; j++) {\\n        if (array[i + j] != pattern[j]) {\\n          found = false;\\n          break;\\n        }\\n      }\\n      if (found) return i;\\n    }\\n    return -1;\\n  }\\n\\n  private static List<byte[]> split(byte[] array, byte[] delimiter) {\\n    List<byte[]> byteArrays = new LinkedList<>();\\n    if (delimiter.length == 0) {\\n      return byteArrays;\\n    }\\n    int begin = 0;\\n\\n    outer:\\n    for (int i = 0; i < array.length - delimiter.length + 1; i++) {\\n      for (int j = 0; j < delimiter.length; j++) {\\n        if (array[i + j] != delimiter[j]) {\\n          continue outer;\\n        }\\n      }\\n      byteArrays.add(Arrays.copyOfRange(array, begin, i));\\n      begin = i + delimiter.length;\\n    }\\n    byteArrays.add(Arrays.copyOfRange(array, begin, array.length));\\n    return byteArrays;\\n  }\\n\\n  public static MyApiResponse sendRequest(String host, int port) throws Exception {\\n    HttpRequest request =\\n      HttpRequest\\n        .newBuilder(url(host, port, \\"hello\\"))\\n        .GET()\\n        .build();\\n    HttpClient client =\\n      HttpClient\\n        .newBuilder()\\n        .connectTimeout(Duration.ofSeconds(30))\\n        .build();\\n    HttpResponse<byte[]> response =\\n      client\\n        .send(request, BodyHandlers.ofByteArray());\\n    String contentTypeHeader = response.headers()\\n      .firstValue(\\"Content-Type\\")\\n      .orElseThrow(() -> new IllegalStateException(\\"No Content-Type header\\"));\\n    byte[] responseBody = response.body();\\n    return parseFormData(contentTypeHeader, responseBody);\\n  }\\n\\n  private static URI url(String host, int port, String endpoint) {\\n    try {\\n      return new URI(\\"http\\", null, host, port, \\"/\\" + endpoint, null, null);\\n    } catch (URISyntaxException e) {\\n      throw new IllegalStateException(\\"Invalid URI: \\" + e.getMessage(), e);\\n    }\\n  }\\n\\n  public static void main(String[] args) throws Exception {\\n    MyApiResponse response = sendRequest(\\"localhost\\", 9876);\\n    System.out.println(response.message1() + \\" \\" + new String(response.message2(), StandardCharsets.UTF_8)); // {\\"hello\\":\\"world\\"} foo=bar\\n  }\\n}\\n```\\n\\n### JS client\\n\\nFor the JS client, we must call [Blob.arrayBuffer()](https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer) to obtain the adequate interface.\\n\\n```js\\nasync function request(host, port) {\\n  const res = await fetch(`http://${host}:${port}/hello`);\\n  const fd = await res.formData();\\n  const message1 = fd.get(\'message1\');\\n  const message2 = fd.get(\'message2\');\\n  const buffer = Buffer.from(await message2.arrayBuffer());\\n  return [message1, buffer];\\n}\\n\\n(async () => {\\n  const response = await request(\'localhost\', 9876)\\n  console.log(response[0], response[1].toString()); // {\\"hello\\":\\"world\\"} foo=bar\\n})();\\n```\\n\\n## Conclusion\\n\\nI wrote this article because I didn\u2019t find much sources that explained how to parse Form-Data in an HTTP response. Most of what I found covers either the building of such a request or how to parse it on the server side.\\n\\nI hope this helps other people implementing these parts, as I have strived to provide working code samples alongside my explanations.\\n\\nWorking on this task and writing this article has provided me a better understand of the Form-Data layout and the various HTTP library APIs around it."},{"id":"MacOS-software-development-tools","metadata":{"permalink":"/blog/MacOS-software-development-tools","editUrl":"https://github.com/kebetsi/kebetsi.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/2023-10-04-macos-dev-tools/index.md","source":"@site/blog/2023-10-04-macos-dev-tools/index.md","title":"MacOS software development tools","description":"I cover the different tools I use on MacOS to facilitate and speed up my work as a software developer.","date":"2023-10-04T00:00:00.000Z","tags":[{"inline":true,"label":"MacOS","permalink":"/blog/tags/mac-os"},{"inline":false,"label":"JavaScript","permalink":"/blog/tags/javascript","description":"all things about JS"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"all things about Java"},{"inline":true,"label":"tools","permalink":"/blog/tags/tools"}],"readingTime":2.875,"hasTruncateMarker":true,"authors":[{"name":"Ilia Kebets","title":"Software engineer @ Sonar","url":"https://github.com/kebetsi","page":{"permalink":"/blog/authors/ilia"},"socials":{"linkedin":"https://www.linkedin.com/in/iliakebets/","github":"https://github.com/kebetsi"},"imageURL":"https://github.com/kebetsi.png","key":"ilia"}],"frontMatter":{"slug":"MacOS-software-development-tools","title":"MacOS software development tools","authors":["ilia"],"tags":["MacOS","javascript","java","tools"]},"unlisted":false,"prevItem":{"title":"Multipart Form-data response parsing in Java and JavaScript","permalink":"/blog/Multipart-Form-data-response-parsing-in-Java-and-JavaScript"}},"content":"I cover the different tools I use on MacOS to facilitate and speed up my work as a software developer.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Terminal\\n\\nI use [iTerm2](https://iterm2.com/) as my terminal. It allows me to split my screen into multiple parts when I need to monitor multiple processes on a single screen. `CMD+D` and `CMD+Shift+D` for horizontal and vertical split respectively. One setting I always tweak is the [line buffer size](https://stackoverflow.com/questions/12459755/zsh-iterm2-increase-number-of-lines-history/28608448#28608448).\\n\\n![multiplexing with iTerm2](./iterm.webp)\\n\\nAs a shell, I use [Oh My Zsh](https://ohmyz.sh/#install) for its out-of-the-box [plugins](https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins) offering shortcuts and because it displays my current branch in git repositories. My main shortcuts are for git and folder navigation:\\n\\n- `gco`: git checkout\\n- `gm`: git merge\\n- `gl`: git pull\\n- `gp`: git push\\n- `ll`: ls -l\\n- `..` and `...`, etc: `cd ..`, `cd ../..`, etc\\n\\nFor folder navigation, I also use [autojump](https://github.com/wting/autojump) which allows me to jump quickly between folders I visited like `j my-repo`. It matches the target folder by name and number of visits.\\n\\nI don\u2019t like the wall of text that `man` pages usually output, so I use [tldr pages](https://tldr.sh/).\\n\\n![TL;DR of `ln` command](./tldr.webp)\\n\\n## Git client\\n\\nI use [tig](https://jonas.github.io/tig/) as a CLI git client, it\u2019s a fast tool that allows me to stage files, cherry-picking blocks of codes or lines if needed. Navigating through the log is very convenient as it supports the same search keys as `less`. Here is a [great article](https://www.atlassian.com/blog/git/git-tig) about it.\\n\\n![Status view in tig](./tig.webp)\\n\\nYou can open the log view with `tig`, but I recommend setting up this alias to open **tig** in Status view directly: `alias s=\\"tig status\\"`. If you use \u201cOh My Zsh\u201d, you should append this in `~/.zshrc`.\\n\\nI configure `git` to track remote branches automatically: `git config --global --add --bool push.autoSetupRemote true`.\\n\\nAlso, I prefer that `git branch` (or `gb`) doesn\u2019t pipe its output in less with `git config --global pager.branch false`.\\n\\n## Node.js\\n\\nI use [nvm](https://github.com/nvm-sh/nvm) to work with multiple versions of Node.js. You can install a new version like 20 with your global dependencies using: `nvm install 20 --reinstall-from=current`.\\n\\n![Print installed Node.js versions, the one in use and the default one](./nvm.webp)\\n\\nSwitch between versions easily with `nvm use 18` and update your default with `nvm alias default 20`.\\n\\n## JavaScript/TypeScrypt IDE\\n\\nAs the majority of people, I use the [VS code](https://code.visualstudio.com/download) IDE for JS/TS.\\n\\n![VS code IDE](./vscode.webp)\\n\\nI open it from the terminal using `code .` which you can set up [like that](https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line).\\n\\nFor extensions:\\n\\n- [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) provides blame information on lines of code, for context\\n- [Jest runner](https://marketplace.visualstudio.com/items?itemName=firsttris.vscode-jest-runner) easily runs single test suites from the IDE, with a debugger if needed\\n- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint), [SonarLint](https://marketplace.visualstudio.com/items?itemName=SonarSource.sonarlint-vscode), [Shellcheck](https://marketplace.visualstudio.com/items?itemName=timonwong.shellcheck), and [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) in the linter department\\n\\n## Java\\n\\nI use [sdkman](https://sdkman.io/) to install and switch between Java versions.\\n\\n![Available Java version, highlighting installed and in use](./sdkman.webp)\\n\\nI use [IntelliJ](https://www.jetbrains.com/idea/) as an IDE for Java. It has a lot more built-in tools for Java development and beats VS code to it. It requires some time to learn all the shortcuts that will make you a power user but makes up for the loading time it spends indexing the projects.\\n\\n![IntelliJ IDE](./intellij.webp)\\n\\n## Misc\\n\\nFor many of the tools here, I used [homebrew](https://brew.sh/) to install them.\\n\\n![List of packages installed with homebrew](./homebrew.webp)\\n\\nFor app multiplexing on the desktop, I use [Moom](https://apps.apple.com/us/app/moom-classic/id419330170?mt=12) which is a paid tool. It allows me to resize apps to fit half or a quarter of a screen like on Windows."}]}}')}}]);