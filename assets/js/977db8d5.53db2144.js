"use strict";(self.webpackChunkilia_kebets_tech_blog=self.webpackChunkilia_kebets_tech_blog||[]).push([[89],{7221:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var r=t(4848),s=t(8453);const a={slug:"Multipart-Form-data-response-parsing-in-Java-and-JavaScript",title:"Multipart Form-data response parsing in Java and JavaScript",authors:["ilia"],tags:["javascript","java","http","response","multipart-form-data"]},o="Multipart Form-data response parsing in Java and JavaScript",i={permalink:"/blog/Multipart-Form-data-response-parsing-in-Java-and-JavaScript",editUrl:"https://github.com/kebetsi/kebetsi.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/2024-09-16-form-data-response/index.md",source:"@site/blog/2024-09-16-form-data-response/index.md",title:"Multipart Form-data response parsing in Java and JavaScript",description:"In this article, I will show you how to implement an HTTP server that replies with form-data and how to parse it from the client. I will provide examples for the server in Node.js, using external libraries and native ones. For the client, I will show implementations in JS and Java.",date:"2024-09-16T00:00:00.000Z",tags:[{inline:!1,label:"JavaScript",permalink:"/blog/tags/javascript",description:"all things about JS"},{inline:!1,label:"Java",permalink:"/blog/tags/java",description:"all things about Java"},{inline:!0,label:"http",permalink:"/blog/tags/http"},{inline:!0,label:"response",permalink:"/blog/tags/response"},{inline:!0,label:"multipart-form-data",permalink:"/blog/tags/multipart-form-data"}],readingTime:10.235,hasTruncateMarker:!0,authors:[{name:"Ilia Kebets",title:"Software engineer @ Sonar",url:"https://github.com/kebetsi",page:{permalink:"/blog/authors/ilia"},socials:{linkedin:"https://www.linkedin.com/in/iliakebets/",github:"https://github.com/kebetsi"},imageURL:"https://github.com/kebetsi.png",key:"ilia"}],frontMatter:{slug:"Multipart-Form-data-response-parsing-in-Java-and-JavaScript",title:"Multipart Form-data response parsing in Java and JavaScript",authors:["ilia"],tags:["javascript","java","http","response","multipart-form-data"]},unlisted:!1,nextItem:{title:"MacOS software development tools",permalink:"/blog/MacOS-software-development-tools"}},l={authorsImageUrls:[void 0]},d=[{value:"Form-data with text",id:"form-data-with-text",level:2},{value:"JS server \u2014 with libraries",id:"js-server--with-libraries",level:3},{value:"JS server \u2014 without libraries",id:"js-server--without-libraries",level:3},{value:"Java client",id:"java-client",level:3},{value:"JS client",id:"js-client",level:3},{value:"Form-data with binary data",id:"form-data-with-binary-data",level:2},{value:"JS server \u2014 with libraries",id:"js-server--with-libraries-1",level:3},{value:"JS server \u2014 without libraries",id:"js-server--without-libraries-1",level:3},{value:"Java client",id:"java-client-1",level:3},{value:"JS client",id:"js-client-1",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["In this article, I will show you how to implement an HTTP server that ",(0,r.jsx)(n.strong,{children:"replies with form-data"})," and how to parse it from the client. I will provide examples for the server in Node.js, using external libraries and native ones. For the client, I will show implementations in JS and Java."]}),"\n",(0,r.jsxs)(n.p,{children:["All the presented code snippets can be found ",(0,r.jsx)(n.a,{href:"https://github.com/kebetsi/kebetsi.github.io/tree/main/code-snippets/2024-09-16-form-data-response#code-snippets-from-multipart-form-data-post",children:"here"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"I will illustrate cases where the parts are only text and a mix of text and binary data."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Learn/Forms/Sending_and_retrieving_form_data",children:["Form-data is the way browsers send the contents of the ",(0,r.jsx)(n.code,{children:"<form>"})," element"]}),". It is also the way for the HTTP protocol to send key-value data in a POST request which supports values of different formats, such as text and binary."]}),"\n",(0,r.jsx)(n.h2,{id:"form-data-with-text",children:"Form-data with text"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"HTTP response of multipart/form-data with text parts",src:t(1815).A+"",width:"1152",height:"552"})}),"\n",(0,r.jsx)(n.h3,{id:"js-server--with-libraries",children:"JS server \u2014 with libraries"}),"\n",(0,r.jsxs)(n.p,{children:["We use the ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/express",children:"express"})," and ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/form-data",children:"form-data"})," libraries in this example for convenience."]}),"\n",(0,r.jsxs)(n.p,{children:["We use JSON data for the text, but it can also be plain text. We append each part with its name, here ",(0,r.jsx)(n.code,{children:"message1"})," and ",(0,r.jsx)(n.code,{children:"message2"})," to the ",(0,r.jsx)(n.code,{children:"formData"})," instance, set the required headers. Finally, we must pipe it into the response stream."]}),"\n",(0,r.jsxs)(n.p,{children:["I had to use ",(0,r.jsx)(n.code,{children:"127.0.0.1"})," instead of ",(0,r.jsx)(n.code,{children:"localhost"})," for the host address on the JS server side, because the Java clients would not resolve it."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const http = require('http');\nconst app = require('express')();\nconst formData = require('form-data');\nconst PORT = '9876';\nconst HOST = '127.0.0.1';\n\nconst message1 = JSON.stringify({ hello: 'world' });\nconst message2 = JSON.stringify({ foo: 'bar' });\n\nconst requestHandler = ((_, response) => {\n  const fd = new formData();\n  fd.append('message1', message1);\n  fd.append('message2', message2);\n  // generates the \"multipart/form-data; boundary=...\" header\n  response.set('Content-Type', fd.getHeaders()['content-type']);\n  response.set('Content-Length', fd.getLengthSync());\n  fd.pipe(response);\n});\n\napp.use(requestHandler);\n\nconst server = http.createServer(app);\nserver.listen(PORT, HOST, err => {\n  if (err) {\n    return console.log('something bad happened', err);\n  }\n  console.log(`server is listening on ${HOST}:${PORT}`);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"js-server--without-libraries",children:"JS server \u2014 without libraries"}),"\n",(0,r.jsx)(n.p,{children:"For a unit test in the Java component, I had to implement a mock server that was not using any libraries. It helped me have a better understanding of the form-data layout."}),"\n",(0,r.jsxs)(n.p,{children:["The body starts with the boundary string which is then used to split every part of the message. The boundary must have a length of up to 70 characters, and you can read more about it ",(0,r.jsx)(n.a,{href:"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html",children:"here"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Then, each part is organized as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Starts with ",(0,r.jsx)(n.code,{children:"\\r\\n"})]}),"\n",(0,r.jsx)(n.li,{children:"its header, which contains the name of the part"}),"\n",(0,r.jsxs)(n.li,{children:["2 times ",(0,r.jsx)(n.code,{children:"\\r\\n"})]}),"\n",(0,r.jsx)(n.li,{children:"its body"}),"\n",(0,r.jsxs)(n.li,{children:["ends with ",(0,r.jsx)(n.code,{children:"\\r\\n"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["We must ensure that the body length in bytes is properly computed and not forget the ",(0,r.jsx)(n.code,{children:"Content-Type"})," header."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const http = require('http');\nconst formData = require('form-data');\nconst PORT = '9876';\nconst HOST = '127.0.0.1';\n\nconst message1 = JSON.stringify({ hello: 'world' });\nconst message2 = JSON.stringify({ foo: 'bar' });\n\nconst requestHandler = (request, response) => {\n  let data = '';\n  request.on('data', chunk => (data += chunk));\n  request.on('end', () => {\n    // do something with the incoming data if needed\n    const boundary = '---------9051914041544843365972754266';\n    const contentTypeHeader = `multipart/form-data; boundary=${boundary}`;\n    let body = '';\n    body += `--${boundary}`;\n    body += `\\r\\n`;\n    body += `Content-Disposition: form-data; name=\"message1\"`;\n    body += `\\r\\n`;\n    body += `\\r\\n`;\n    body += `${message1}`;\n    body += `\\r\\n`;\n    body += `--${boundary}`;\n    body += `\\r\\n`;\n    body += `Content-Disposition: form-data; name=\"message2\"`;\n    body += `\\r\\n`;\n    body += `\\r\\n`;\n    body += `${message2}`;\n    body += `\\r\\n`;\n    body += `--${boundary}--`;\n    body += `\\r\\n`;\n    response.writeHead(200, {\n      'Content-Type': contentTypeHeader,\n      'Content-Length': Buffer.byteLength(body, 'utf-8'),\n    });\n    response.end(body);\n  });\n};\n\nconst server = http.createServer(requestHandler);\n\nserver.listen(PORT, HOST, err => {\n  if (err) {\n    return console.log('something bad happened', err);\n  }\n  console.log(`server is listening on ${HOST}:${PORT}`);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"java-client",children:"Java client"}),"\n",(0,r.jsxs)(n.p,{children:["We start by extracting the boundary string from the ",(0,r.jsx)(n.code,{children:"Content-Type"})," header, which we use to split the separate parts of the body with ",(0,r.jsx)(n.code,{children:"response.body().split(...)"}),". Most client libraries will generate one for you as you saw in the previous example."]}),"\n",(0,r.jsxs)(n.p,{children:["Then we use the ",(0,r.jsx)(n.code,{children:"\\r\\n\\r\\n"})," separator to split between each part\u2019s header and body. As you can see in the library-less server implementation above, we must trim the ",(0,r.jsx)(n.code,{children:"\\r\\n"})," form-data boilerplate. If we are handling JSON data, we could simplify this part using ",(0,r.jsx)(n.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--",children:"String.trim()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.time.Duration;\n\npublic class MyClient {\n\n  public record MyApiResponse(String message1, String message2) {};\n\n  public static MyApiResponse parseFormData(String contentTypeHeader, String responseBody) {\n    String boundary = "--" + contentTypeHeader.split("boundary=")[1];\n    String[] parts = responseBody.split(boundary);\n    String message1 = null;\n    String message2 = null;\n    for (String part : parts) {\n      // Split the part into headers and body\n      int separatorIndex = part.indexOf("\\r\\n\\r\\n");\n      if (separatorIndex == -1) {\n        // Skip if there\'s no body\n        continue;\n      }\n      // I remove the first 2 bytes, representing "\\r\\n" before the headers\n      String headers = part.substring(2, separatorIndex);\n      // I remove the first 4 bytes and last 2.\n      // They are the "\\r\\n\\r\\n" before and "\\r\\n" after the payload\n      String partBody = part.substring(separatorIndex + 4, part.length() - 2);\n\n      if (headers.contains("message1")) {\n        message1 = partBody;\n      } else if (headers.contains("message2")) {\n        message2 = partBody;\n      }\n    }\n    if (message1 == null || message2 == null) {\n      throw new IllegalStateException("Data missing from response");\n    }\n    return new MyApiResponse(message1, message2);\n  }\n\n  public static MyApiResponse sendRequest(String host, int port) throws Exception {\n    HttpRequest request =\n      HttpRequest\n        .newBuilder()\n        .uri(url(host, port, "hello"))\n        .GET()\n        .build();\n    HttpClient client =\n      HttpClient\n        .newBuilder()\n        .connectTimeout(Duration.ofSeconds(30))\n        .build();\n    HttpResponse<String> response =\n      client\n        .send(request, BodyHandlers.ofString());\n    String contentTypeHeader = response.headers()\n      .firstValue("Content-Type")\n      .orElseThrow(() -> new IllegalStateException("No Content-Type header"));\n    String responseBody = response.body();\n    return parseFormData(contentTypeHeader, responseBody);\n  }\n\n  private static URI url(String host, int port, String endpoint) {\n    try {\n      return new URI("http", null, host, port, "/" + endpoint, null, null);\n    } catch (URISyntaxException e) {\n      throw new IllegalStateException("Invalid URI: " + e.getMessage(), e);\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    MyApiResponse response = sendRequest("localhost", 9876);\n    System.out.println(response); // MyApiResponse[message1={"hello":"world"}, message2={"foo":"bar"}]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"js-client",children:"JS client"}),"\n",(0,r.jsxs)(n.p,{children:["For the HTTP request, we use the ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",children:"fetch API"})," available in modern browsers and Node.js since version 18."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function request(host, port) {\n  const res = await fetch(`http://${host}:${port}/hello`);\n  const fd = await res.formData();\n  const message1 = fd.get('message1');\n  const message2 = fd.get('message2');\n  return [message1, message2];\n}\n\n(async () => {\n  const response = await request('localhost', 9876)\n  console.log(response); // [ '{\"hello\":\"world\"}', '{\"foo\":\"bar\"}' ]\n})();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"form-data-with-binary-data",children:"Form-data with binary data"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"HTTP response of multipart/form-data with text and binary parts",src:t(7577).A+"",width:"1332",height:"624"})}),"\n",(0,r.jsxs)(n.p,{children:["We change the ",(0,r.jsx)(n.code,{children:"message2"})," part to be treated as a binary, while ",(0,r.jsx)(n.code,{children:"message1"})," stays the same."]}),"\n",(0,r.jsx)(n.h3,{id:"js-server--with-libraries-1",children:"JS server \u2014 with libraries"}),"\n",(0,r.jsxs)(n.p,{children:["We use a simple string for ",(0,r.jsx)(n.code,{children:"message2"}),", but it accepts a Buffer object such as the bytes from a file given by the result of ",(0,r.jsx)(n.code,{children:"fs.readFileSync()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const http = require('http');\nconst app = require('express')();\nconst formData = require('form-data');\n// const fs = require('fs');\n\nconst PORT = '9876';\nconst HOST = '127.0.0.1';\n\nconst message1 = JSON.stringify({ hello: 'world' });\nconst message2 = Buffer.from('foo=bar');\n// const message2 = fs.readFileSync('path/to/my/file');\n\nconst requestHandler = ((_, response) => {\n  const fd = new formData();\n  fd.append('message1', message1);\n  fd.append('message2', message2);\n  response.set('Content-Type', fd.getHeaders()['content-type']);\n  response.set('Content-Length', fd.getLengthSync());\n  fd.pipe(response);\n});\n\napp.use(requestHandler);\n\nconst server = http.createServer(app);\nserver.listen(PORT, HOST, err => {\n  if (err) {\n    return console.log('something bad happened', err);\n  }\n  console.log(`server is listening on ${HOST}:${PORT}`);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"js-server--without-libraries-1",children:"JS server \u2014 without libraries"}),"\n",(0,r.jsxs)(n.p,{children:["When sending binary data, we need to convert the string parts and separators using ",(0,r.jsx)(n.a,{href:"https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding",children:"Buffer.from()"})," and join them using ",(0,r.jsx)(n.a,{href:"https://nodejs.org/api/buffer.html#static-method-bufferconcatlist-totallength",children:"Buffer.concat()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For the binary part, we need to add a ",(0,r.jsx)(n.code,{children:"Content-Type"})," header inside the body."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const http = require('http');\nconst formData = require('form-data');\n// const fs = require('fs');\n\nconst PORT = '9876';\nconst HOST = '127.0.0.1';\n\nconst message1 = JSON.stringify({ hello: 'world' });\nconst message2 = Buffer.from('foo=bar');\n// const message2 = fs.readFileSync('path/to/my/file');\n\nconst requestHandler = (request, response) => {\n  let data = '';\n  request.on('data', chunk => (data += chunk));\n  request.on('end', () => {\n\n    const boundary = '---------9051914041544843365972754266';\n    const contentTypeHeader = `multipart/form-data; boundary=${boundary}`;\n    let firstPart = '';\n    firstPart += `--${boundary}`;\n    firstPart += `\\r\\n`;\n    firstPart += `Content-Disposition: form-data; name=\"message1\"`;\n    firstPart += `\\r\\n`;\n    firstPart += `\\r\\n`;\n    firstPart += `${message1}`;\n    firstPart += `\\r\\n`;\n    firstPart += `--${boundary}`;\n    firstPart += `\\r\\n`;\n    firstPart += `Content-Disposition: form-data; name=\"message2\"`;\n    firstPart += `\\r\\n`;\n    firstPart += `Content-Type: application/octet-stream`;\n    firstPart += `\\r\\n`;\n    firstPart += `\\r\\n`;\n    let lastPart = '';\n    lastPart += `\\r\\n`;\n    lastPart += `--${boundary}--`;\n    lastPart += `\\r\\n`;\n    const body = Buffer.concat([Buffer.from(firstPart), message2, Buffer.from(lastPart)]);\n    const contentLength = body.length;\n    response.writeHead(200, {\n      'Content-Type': contentTypeHeader,\n      'Content-Length': contentLength,\n    });\n    response.end(body);\n  });\n};\n\nconst server = http.createServer(requestHandler);\n\nserver.listen(PORT, HOST, err => {\n  if (err) {\n    return console.log('something bad happened', err);\n  }\n  console.log(`server is listening on ${HOST}:${PORT}`);\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"java-client-1",children:"Java client"}),"\n",(0,r.jsx)(n.p,{children:"Now, the change is that the HTTP response body is a byte array, so we must manipulate bytes instead of Strings in our parsing function."}),"\n",(0,r.jsxs)(n.p,{children:["First, we translate the boundary in bytes using ",(0,r.jsx)(n.code,{children:"boundary.getBytes()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Then we use custom ",(0,r.jsx)(n.code,{children:"indexOf()"})," and ",(0,r.jsx)(n.code,{children:"split()"})," methods that operate on bytes to separate the Form-Data parts. We must also trim the headers and body of the different parts."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.net.http.HttpResponse.BodyHandlers;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class MyClientData {\n\n  public record MyApiResponse(String message1, byte[] message2) {};\n\n  public static MyApiResponse parseFormData(String contentTypeHeader, byte[] responseBody) {\n    String boundary = "--" + contentTypeHeader.split("boundary=")[1];\n    byte[] boundaryBytes = boundary.getBytes(StandardCharsets.ISO_8859_1);\n    List<byte[]> parts = split(responseBody, boundaryBytes);\n\n    String message1 = null;\n    byte[] message2 = null;\n\n    for (byte[] part : parts) {\n      int separatorIndex = indexOf(part, "\\r\\n\\r\\n".getBytes(StandardCharsets.ISO_8859_1));\n      if (separatorIndex == -1) {\n        // Skip if there\'s no body\n        continue;\n      }\n\n      // I remove the first 2 bytes, representing "\\r\\n" before the headers\n      byte[] headers = Arrays.copyOfRange(part, 2, separatorIndex);\n      // I remove the first 4 bytes and last 2.\n      // They are the "\\r\\n\\r\\n" before and "\\r\\n" after the payload\n      byte[] body = Arrays.copyOfRange(part, separatorIndex + 4, part.length - 2);\n\n      String headersStr = new String(headers, StandardCharsets.UTF_8);\n\n      if (headersStr.contains("message1")) {\n        message1 = new String(body, StandardCharsets.UTF_8);\n      } else if (headersStr.contains("message2")) {\n        message2 = body;\n      }\n    }\n    if (message1 == null || message2 == null) {\n      throw new IllegalStateException("Data missing from response");\n    }\n    return new MyApiResponse(message1, message2);\n  }\n\n  private static int indexOf(byte[] array, byte[] pattern) {\n    for (int i = 0; i < array.length - pattern.length + 1; i++) {\n      boolean found = true;\n      for (int j = 0; j < pattern.length; j++) {\n        if (array[i + j] != pattern[j]) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n    return -1;\n  }\n\n  private static List<byte[]> split(byte[] array, byte[] delimiter) {\n    List<byte[]> byteArrays = new LinkedList<>();\n    if (delimiter.length == 0) {\n      return byteArrays;\n    }\n    int begin = 0;\n\n    outer:\n    for (int i = 0; i < array.length - delimiter.length + 1; i++) {\n      for (int j = 0; j < delimiter.length; j++) {\n        if (array[i + j] != delimiter[j]) {\n          continue outer;\n        }\n      }\n      byteArrays.add(Arrays.copyOfRange(array, begin, i));\n      begin = i + delimiter.length;\n    }\n    byteArrays.add(Arrays.copyOfRange(array, begin, array.length));\n    return byteArrays;\n  }\n\n  public static MyApiResponse sendRequest(String host, int port) throws Exception {\n    HttpRequest request =\n      HttpRequest\n        .newBuilder(url(host, port, "hello"))\n        .GET()\n        .build();\n    HttpClient client =\n      HttpClient\n        .newBuilder()\n        .connectTimeout(Duration.ofSeconds(30))\n        .build();\n    HttpResponse<byte[]> response =\n      client\n        .send(request, BodyHandlers.ofByteArray());\n    String contentTypeHeader = response.headers()\n      .firstValue("Content-Type")\n      .orElseThrow(() -> new IllegalStateException("No Content-Type header"));\n    byte[] responseBody = response.body();\n    return parseFormData(contentTypeHeader, responseBody);\n  }\n\n  private static URI url(String host, int port, String endpoint) {\n    try {\n      return new URI("http", null, host, port, "/" + endpoint, null, null);\n    } catch (URISyntaxException e) {\n      throw new IllegalStateException("Invalid URI: " + e.getMessage(), e);\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    MyApiResponse response = sendRequest("localhost", 9876);\n    System.out.println(response.message1() + " " + new String(response.message2(), StandardCharsets.UTF_8)); // {"hello":"world"} foo=bar\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"js-client-1",children:"JS client"}),"\n",(0,r.jsxs)(n.p,{children:["For the JS client, we must call ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer",children:"Blob.arrayBuffer()"})," to obtain the adequate interface."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function request(host, port) {\n  const res = await fetch(`http://${host}:${port}/hello`);\n  const fd = await res.formData();\n  const message1 = fd.get('message1');\n  const message2 = fd.get('message2');\n  const buffer = Buffer.from(await message2.arrayBuffer());\n  return [message1, buffer];\n}\n\n(async () => {\n  const response = await request('localhost', 9876)\n  console.log(response[0], response[1].toString()); // {\"hello\":\"world\"} foo=bar\n})();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"I wrote this article because I didn\u2019t find much sources that explained how to parse Form-Data in an HTTP response. Most of what I found covers either the building of such a request or how to parse it on the server side."}),"\n",(0,r.jsx)(n.p,{children:"I hope this helps other people implementing these parts, as I have strived to provide working code samples alongside my explanations."}),"\n",(0,r.jsx)(n.p,{children:"Working on this task and writing this article has provided me a better understand of the Form-Data layout and the various HTTP library APIs around it."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},7577:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/form-data-data-7cebb3e3c0f38ea9eb1568c18e8349a5.webp"},1815:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/form-data-txt-4474f52812c716ef1997ba01938dcdf6.webp"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);